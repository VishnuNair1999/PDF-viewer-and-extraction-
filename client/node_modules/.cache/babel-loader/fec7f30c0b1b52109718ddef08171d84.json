{"ast":null,"code":"import { __extends, __spreadArrays } from \"tslib\";\nimport PDFName from \"./PDFName\";\nimport PDFNull from \"./PDFNull\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\n\nvar PDFDict =\n/** @class */\nfunction (_super) {\n  __extends(PDFDict, _super);\n\n  function PDFDict(map, context) {\n    var _this = _super.call(this) || this;\n\n    _this.dict = map;\n    _this.context = context;\n    return _this;\n  }\n\n  PDFDict.prototype.keys = function () {\n    return Array.from(this.dict.keys());\n  };\n\n  PDFDict.prototype.values = function () {\n    return Array.from(this.dict.values());\n  };\n\n  PDFDict.prototype.entries = function () {\n    return Array.from(this.dict.entries());\n  };\n\n  PDFDict.prototype.set = function (key, value) {\n    this.dict.set(key, value);\n  };\n\n  PDFDict.prototype.get = function (key, // TODO: `preservePDFNull` is for backwards compatibility. Should be\n  // removed in next breaking API change.\n  preservePDFNull) {\n    if (preservePDFNull === void 0) {\n      preservePDFNull = false;\n    }\n\n    var value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n\n  PDFDict.prototype.has = function (key) {\n    var value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  };\n\n  PDFDict.prototype.lookupMaybe = function (key) {\n    var _a;\n\n    var types = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    } // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n\n\n    var preservePDFNull = types.includes(PDFNull);\n\n    var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n\n  PDFDict.prototype.lookup = function (key) {\n    var _a;\n\n    var types = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    } // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n\n\n    var preservePDFNull = types.includes(PDFNull);\n\n    var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n\n  PDFDict.prototype.delete = function (key) {\n    return this.dict.delete(key);\n  };\n\n  PDFDict.prototype.asMap = function () {\n    return new Map(this.dict);\n  };\n  /** Generate a random key that doesn't exist in current key set */\n\n\n  PDFDict.prototype.uniqueKey = function (tag) {\n    if (tag === void 0) {\n      tag = '';\n    }\n\n    var existingKeys = this.keys();\n    var key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n\n    return key;\n  };\n\n  PDFDict.prototype.clone = function (context) {\n    var clone = PDFDict.withContext(context || this.context);\n    var entries = this.entries();\n\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n      clone.set(key, value);\n    }\n\n    return clone;\n  };\n\n  PDFDict.prototype.toString = function () {\n    var dictString = '<<\\n';\n    var entries = this.entries();\n\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n\n    dictString += '>>';\n    return dictString;\n  };\n\n  PDFDict.prototype.sizeInBytes = function () {\n    var size = 5;\n    var entries = this.entries();\n\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n\n    return size;\n  };\n\n  PDFDict.prototype.copyBytesInto = function (buffer, offset) {\n    var initialOffset = offset;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n    var entries = this.entries();\n\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n    return offset - initialOffset;\n  };\n\n  PDFDict.withContext = function (context) {\n    return new PDFDict(new Map(), context);\n  };\n\n  PDFDict.fromMapWithContext = function (map, context) {\n    return new PDFDict(map, context);\n  };\n\n  return PDFDict;\n}(PDFObject);\n\nexport default PDFDict;","map":{"version":3,"sources":["C:\\Users\\vishn\\Desktop\\AuthInMern\\client\\node_modules\\pdf-lib\\src\\core\\objects\\PDFDict.ts"],"names":[],"mappings":"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","sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\nimport PDFBool from 'src/core/objects/PDFBool';\nimport PDFHexString from 'src/core/objects/PDFHexString';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNull from 'src/core/objects/PDFNull';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFString from 'src/core/objects/PDFString';\nimport PDFContext from 'src/core/PDFContext';\nimport CharCodes from 'src/core/syntax/CharCodes';\n\nexport type DictMap = Map<PDFName, PDFObject>;\n\nclass PDFDict extends PDFObject {\n  static withContext = (context: PDFContext) => new PDFDict(new Map(), context);\n\n  static fromMapWithContext = (map: DictMap, context: PDFContext) =>\n    new PDFDict(map, context);\n\n  readonly context: PDFContext;\n\n  private readonly dict: DictMap;\n\n  protected constructor(map: DictMap, context: PDFContext) {\n    super();\n    this.dict = map;\n    this.context = context;\n  }\n\n  keys(): PDFName[] {\n    return Array.from(this.dict.keys());\n  }\n\n  values(): PDFObject[] {\n    return Array.from(this.dict.values());\n  }\n\n  entries(): [PDFName, PDFObject][] {\n    return Array.from(this.dict.entries());\n  }\n\n  set(key: PDFName, value: PDFObject): void {\n    this.dict.set(key, value);\n  }\n\n  get(\n    key: PDFName,\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    preservePDFNull = false,\n  ): PDFObject | undefined {\n    const value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  }\n\n  has(key: PDFName): boolean {\n    const value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  }\n\n  lookupMaybe(key: PDFName, type: typeof PDFArray): PDFArray | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFBool): PDFBool | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFDict): PDFDict | undefined;\n  lookupMaybe(\n    key: PDFName,\n    type: typeof PDFHexString,\n  ): PDFHexString | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFName): PDFName | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNull): typeof PDFNull | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNumber): PDFNumber | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFStream): PDFStream | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFRef): PDFRef | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFString): PDFString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray | undefined;\n\n  lookupMaybe(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookupMaybe(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  lookup(key: PDFName): PDFObject | undefined;\n  lookup(key: PDFName, type: typeof PDFArray): PDFArray;\n  lookup(key: PDFName, type: typeof PDFBool): PDFBool;\n  lookup(key: PDFName, type: typeof PDFDict): PDFDict;\n  lookup(key: PDFName, type: typeof PDFHexString): PDFHexString;\n  lookup(key: PDFName, type: typeof PDFName): PDFName;\n  lookup(key: PDFName, type: typeof PDFNull): typeof PDFNull;\n  lookup(key: PDFName, type: typeof PDFNumber): PDFNumber;\n  lookup(key: PDFName, type: typeof PDFStream): PDFStream;\n  lookup(key: PDFName, type: typeof PDFRef): PDFRef;\n  lookup(key: PDFName, type: typeof PDFString): PDFString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray;\n\n  lookup(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookup(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  delete(key: PDFName): boolean {\n    return this.dict.delete(key);\n  }\n\n  asMap(): Map<PDFName, PDFObject> {\n    return new Map(this.dict);\n  }\n\n  /** Generate a random key that doesn't exist in current key set */\n  uniqueKey(tag = ''): PDFName {\n    const existingKeys = this.keys();\n    let key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  }\n\n  clone(context?: PDFContext): PDFDict {\n    const clone = PDFDict.withContext(context || this.context);\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      clone.set(key, value);\n    }\n    return clone;\n  }\n\n  toString(): string {\n    let dictString = '<<\\n';\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  }\n\n  sizeInBytes(): number {\n    let size = 5;\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    const initialOffset = offset;\n\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n\n    return offset - initialOffset;\n  }\n}\n\nexport default PDFDict;\n"]},"metadata":{},"sourceType":"module"}