{"ast":null,"code":"import { NextByteAssertionError } from \"../errors\";\nimport { decodePDFRawStream } from \"../streams/decode\";\nimport CharCodes from \"../syntax/CharCodes\"; // TODO: See how line/col tracking affects performance\n\nvar ByteStream =\n/** @class */\nfunction () {\n  function ByteStream(bytes) {\n    this.idx = 0;\n    this.line = 0;\n    this.column = 0;\n    this.bytes = bytes;\n    this.length = this.bytes.length;\n  }\n\n  ByteStream.prototype.moveTo = function (offset) {\n    this.idx = offset;\n  };\n\n  ByteStream.prototype.next = function () {\n    var byte = this.bytes[this.idx++];\n\n    if (byte === CharCodes.Newline) {\n      this.line += 1;\n      this.column = 0;\n    } else {\n      this.column += 1;\n    }\n\n    return byte;\n  };\n\n  ByteStream.prototype.assertNext = function (expected) {\n    if (this.peek() !== expected) {\n      throw new NextByteAssertionError(this.position(), expected, this.peek());\n    }\n\n    return this.next();\n  };\n\n  ByteStream.prototype.peek = function () {\n    return this.bytes[this.idx];\n  };\n\n  ByteStream.prototype.peekAhead = function (steps) {\n    return this.bytes[this.idx + steps];\n  };\n\n  ByteStream.prototype.peekAt = function (offset) {\n    return this.bytes[offset];\n  };\n\n  ByteStream.prototype.done = function () {\n    return this.idx >= this.length;\n  };\n\n  ByteStream.prototype.offset = function () {\n    return this.idx;\n  };\n\n  ByteStream.prototype.slice = function (start, end) {\n    return this.bytes.slice(start, end);\n  };\n\n  ByteStream.prototype.position = function () {\n    return {\n      line: this.line,\n      column: this.column,\n      offset: this.idx\n    };\n  };\n\n  ByteStream.of = function (bytes) {\n    return new ByteStream(bytes);\n  };\n\n  ByteStream.fromPDFRawStream = function (rawStream) {\n    return ByteStream.of(decodePDFRawStream(rawStream).decode());\n  };\n\n  return ByteStream;\n}();\n\nexport default ByteStream;","map":{"version":3,"sources":["C:\\Users\\vishn\\Desktop\\AuthInMern\\client\\node_modules\\pdf-lib\\src\\core\\parser\\ByteStream.ts"],"names":[],"mappings":"AAAA,SAAS,sBAAT,QAAiC,WAAjC;AAEA,SAAS,kBAAT,QAA6B,mBAA7B;AACA,OAAO,SAAP,MAAgB,qBAAhB,C,CAEA;;AACA,IAAA,UAAA;AAAA;AAAA,YAAA;AAaE,WAAA,UAAA,CAAY,KAAZ,EAA6B;AAJrB,SAAA,GAAA,GAAM,CAAN;AACA,SAAA,IAAA,GAAO,CAAP;AACA,SAAA,MAAA,GAAS,CAAT;AAGN,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,MAAL,GAAc,KAAK,KAAL,CAAW,MAAzB;AACD;;AAED,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,MAAP,EAAqB;AACnB,SAAK,GAAL,GAAW,MAAX;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,QAAM,IAAI,GAAG,KAAK,KAAL,CAAW,KAAK,GAAL,EAAX,CAAb;;AACA,QAAI,IAAI,KAAK,SAAS,CAAC,OAAvB,EAAgC;AAC9B,WAAK,IAAL,IAAa,CAAb;AACA,WAAK,MAAL,GAAc,CAAd;AACD,KAHD,MAGO;AACL,WAAK,MAAL,IAAe,CAAf;AACD;;AACD,WAAO,IAAP;AACD,GATD;;AAWA,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,QAAX,EAA2B;AACzB,QAAI,KAAK,IAAL,OAAgB,QAApB,EAA8B;AAC5B,YAAM,IAAI,sBAAJ,CAA2B,KAAK,QAAL,EAA3B,EAA4C,QAA5C,EAAsD,KAAK,IAAL,EAAtD,CAAN;AACD;;AACD,WAAO,KAAK,IAAL,EAAP;AACD,GALD;;AAOA,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,WAAO,KAAK,KAAL,CAAW,KAAK,GAAhB,CAAP;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAAuB;AACrB,WAAO,KAAK,KAAL,CAAW,KAAK,GAAL,GAAW,KAAtB,CAAP;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,MAAP,EAAqB;AACnB,WAAO,KAAK,KAAL,CAAW,MAAX,CAAP;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,WAAO,KAAK,GAAL,IAAY,KAAK,MAAxB;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,WAAO,KAAK,GAAZ;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,KAAN,EAAqB,GAArB,EAAgC;AAC9B,WAAO,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAjB,EAAwB,GAAxB,CAAP;AACD,GAFD;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO;AAAE,MAAA,IAAI,EAAE,KAAK,IAAb;AAAmB,MAAA,MAAM,EAAE,KAAK,MAAhC;AAAwC,MAAA,MAAM,EAAE,KAAK;AAArD,KAAP;AACD,GAFD;;AA/DO,EAAA,UAAA,CAAA,EAAA,GAAK,UAAC,KAAD,EAAkB;AAAK,WAAA,IAAI,UAAJ,CAAA,KAAA,CAAA;AAAqB,GAAjD;;AAEA,EAAA,UAAA,CAAA,gBAAA,GAAmB,UAAC,SAAD,EAAwB;AAChD,WAAA,UAAU,CAAC,EAAX,CAAc,kBAAkB,CAAC,SAAD,CAAlB,CAA8B,MAA9B,EAAd,CAAA;AAAqD,GADhD;;AAgET,SAAA,UAAA;AAAC,CAnED,EAAA;;AAqEA,eAAe,UAAf","sourcesContent":["import { NextByteAssertionError } from 'src/core/errors';\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\nimport { decodePDFRawStream } from 'src/core/streams/decode';\nimport CharCodes from 'src/core/syntax/CharCodes';\n\n// TODO: See how line/col tracking affects performance\nclass ByteStream {\n  static of = (bytes: Uint8Array) => new ByteStream(bytes);\n\n  static fromPDFRawStream = (rawStream: PDFRawStream) =>\n    ByteStream.of(decodePDFRawStream(rawStream).decode());\n\n  private readonly bytes: Uint8Array;\n  private readonly length: number;\n\n  private idx = 0;\n  private line = 0;\n  private column = 0;\n\n  constructor(bytes: Uint8Array) {\n    this.bytes = bytes;\n    this.length = this.bytes.length;\n  }\n\n  moveTo(offset: number): void {\n    this.idx = offset;\n  }\n\n  next(): number {\n    const byte = this.bytes[this.idx++];\n    if (byte === CharCodes.Newline) {\n      this.line += 1;\n      this.column = 0;\n    } else {\n      this.column += 1;\n    }\n    return byte;\n  }\n\n  assertNext(expected: number): number {\n    if (this.peek() !== expected) {\n      throw new NextByteAssertionError(this.position(), expected, this.peek());\n    }\n    return this.next();\n  }\n\n  peek(): number {\n    return this.bytes[this.idx];\n  }\n\n  peekAhead(steps: number) {\n    return this.bytes[this.idx + steps];\n  }\n\n  peekAt(offset: number) {\n    return this.bytes[offset];\n  }\n\n  done(): boolean {\n    return this.idx >= this.length;\n  }\n\n  offset(): number {\n    return this.idx;\n  }\n\n  slice(start: number, end: number): Uint8Array {\n    return this.bytes.slice(start, end);\n  }\n\n  position(): { line: number; column: number; offset: number } {\n    return { line: this.line, column: this.column, offset: this.idx };\n  }\n}\n\nexport default ByteStream;\n"]},"metadata":{},"sourceType":"module"}