{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PrivateConstructorError } from \"../errors\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsIrregular } from \"../syntax/Irregular\";\nimport { charFromHexCode, copyStringIntoBuffer, toCharCode, toHexString } from \"../../utils\";\n\nvar decodeName = function decodeName(name) {\n  return name.replace(/#([\\dABCDEF]{2})/g, function (_, hex) {\n    return charFromHexCode(hex);\n  });\n};\n\nvar isRegularChar = function isRegularChar(charCode) {\n  return charCode >= CharCodes.ExclamationPoint && charCode <= CharCodes.Tilde && !IsIrregular[charCode];\n};\n\nvar ENFORCER = {};\nvar pool = new Map();\n\nvar PDFName =\n/** @class */\nfunction (_super) {\n  __extends(PDFName, _super);\n\n  function PDFName(enforcer, name) {\n    var _this = this;\n\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    _this = _super.call(this) || this;\n    var encodedName = '/';\n\n    for (var idx = 0, len = name.length; idx < len; idx++) {\n      var character = name[idx];\n      var code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : \"#\" + toHexString(code);\n    }\n\n    _this.encodedName = encodedName;\n    return _this;\n  }\n\n  PDFName.prototype.asBytes = function () {\n    var bytes = [];\n    var hex = '';\n    var escaped = false;\n\n    var pushByte = function pushByte(byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n\n    for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      var char = this.encodedName[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.encodedName[idx + 1];\n\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte >= CharCodes.Zero && byte <= CharCodes.Nine || byte >= CharCodes.a && byte <= CharCodes.f || byte >= CharCodes.A && byte <= CharCodes.F) {\n          hex += char;\n\n          if (hex.length === 2 || !(nextChar >= '0' && nextChar <= '9' || nextChar >= 'a' && nextChar <= 'f' || nextChar >= 'A' && nextChar <= 'F')) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n\n    return new Uint8Array(bytes);\n  }; // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n\n\n  PDFName.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    return String.fromCharCode.apply(String, Array.from(bytes));\n  };\n\n  PDFName.prototype.asString = function () {\n    return this.encodedName;\n  };\n  /** @deprecated in favor of [[PDFName.asString]] */\n\n\n  PDFName.prototype.value = function () {\n    return this.encodedName;\n  };\n\n  PDFName.prototype.clone = function () {\n    return this;\n  };\n\n  PDFName.prototype.toString = function () {\n    return this.encodedName;\n  };\n\n  PDFName.prototype.sizeInBytes = function () {\n    return this.encodedName.length;\n  };\n\n  PDFName.prototype.copyBytesInto = function (buffer, offset) {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  };\n\n  PDFName.of = function (name) {\n    var decodedValue = decodeName(name);\n    var instance = pool.get(decodedValue);\n\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n\n    return instance;\n  };\n  /* tslint:disable member-ordering */\n\n\n  PDFName.Length = PDFName.of('Length');\n  PDFName.FlateDecode = PDFName.of('FlateDecode');\n  PDFName.Resources = PDFName.of('Resources');\n  PDFName.Font = PDFName.of('Font');\n  PDFName.XObject = PDFName.of('XObject');\n  PDFName.ExtGState = PDFName.of('ExtGState');\n  PDFName.Contents = PDFName.of('Contents');\n  PDFName.Type = PDFName.of('Type');\n  PDFName.Parent = PDFName.of('Parent');\n  PDFName.MediaBox = PDFName.of('MediaBox');\n  PDFName.Page = PDFName.of('Page');\n  PDFName.Annots = PDFName.of('Annots');\n  PDFName.TrimBox = PDFName.of('TrimBox');\n  PDFName.ArtBox = PDFName.of('ArtBox');\n  PDFName.BleedBox = PDFName.of('BleedBox');\n  PDFName.CropBox = PDFName.of('CropBox');\n  PDFName.Rotate = PDFName.of('Rotate');\n  PDFName.Title = PDFName.of('Title');\n  PDFName.Author = PDFName.of('Author');\n  PDFName.Subject = PDFName.of('Subject');\n  PDFName.Creator = PDFName.of('Creator');\n  PDFName.Keywords = PDFName.of('Keywords');\n  PDFName.Producer = PDFName.of('Producer');\n  PDFName.CreationDate = PDFName.of('CreationDate');\n  PDFName.ModDate = PDFName.of('ModDate');\n  return PDFName;\n}(PDFObject);\n\nexport default PDFName;","map":{"version":3,"sources":["C:\\Users\\vishn\\Desktop\\AuthInMern\\client\\node_modules\\pdf-lib\\src\\core\\objects\\PDFName.ts"],"names":[],"mappings":"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","sourcesContent":["import { PrivateConstructorError } from 'src/core/errors';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { IsIrregular } from 'src/core/syntax/Irregular';\nimport {\n  charFromHexCode,\n  copyStringIntoBuffer,\n  toCharCode,\n  toHexString,\n} from 'src/utils';\n\nconst decodeName = (name: string) =>\n  name.replace(/#([\\dABCDEF]{2})/g, (_, hex) => charFromHexCode(hex));\n\nconst isRegularChar = (charCode: number) =>\n  charCode >= CharCodes.ExclamationPoint &&\n  charCode <= CharCodes.Tilde &&\n  !IsIrregular[charCode];\n\nconst ENFORCER = {};\nconst pool = new Map<string, PDFName>();\n\nclass PDFName extends PDFObject {\n  static of = (name: string): PDFName => {\n    const decodedValue = decodeName(name);\n\n    let instance = pool.get(decodedValue);\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n\n    return instance;\n  };\n\n  /* tslint:disable member-ordering */\n  static readonly Length = PDFName.of('Length');\n  static readonly FlateDecode = PDFName.of('FlateDecode');\n  static readonly Resources = PDFName.of('Resources');\n  static readonly Font = PDFName.of('Font');\n  static readonly XObject = PDFName.of('XObject');\n  static readonly ExtGState = PDFName.of('ExtGState');\n  static readonly Contents = PDFName.of('Contents');\n  static readonly Type = PDFName.of('Type');\n  static readonly Parent = PDFName.of('Parent');\n  static readonly MediaBox = PDFName.of('MediaBox');\n  static readonly Page = PDFName.of('Page');\n  static readonly Annots = PDFName.of('Annots');\n  static readonly TrimBox = PDFName.of('TrimBox');\n  static readonly ArtBox = PDFName.of('ArtBox');\n  static readonly BleedBox = PDFName.of('BleedBox');\n  static readonly CropBox = PDFName.of('CropBox');\n  static readonly Rotate = PDFName.of('Rotate');\n  static readonly Title = PDFName.of('Title');\n  static readonly Author = PDFName.of('Author');\n  static readonly Subject = PDFName.of('Subject');\n  static readonly Creator = PDFName.of('Creator');\n  static readonly Keywords = PDFName.of('Keywords');\n  static readonly Producer = PDFName.of('Producer');\n  static readonly CreationDate = PDFName.of('CreationDate');\n  static readonly ModDate = PDFName.of('ModDate');\n  /* tslint:enable member-ordering */\n\n  private readonly encodedName: string;\n\n  private constructor(enforcer: any, name: string) {\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    super();\n\n    let encodedName = '/';\n    for (let idx = 0, len = name.length; idx < len; idx++) {\n      const character = name[idx];\n      const code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : `#${toHexString(code)}`;\n    }\n\n    this.encodedName = encodedName;\n  }\n\n  asBytes(): Uint8Array {\n    const bytes: number[] = [];\n\n    let hex = '';\n    let escaped = false;\n\n    const pushByte = (byte?: number) => {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n\n    for (let idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      const char = this.encodedName[idx];\n      const byte = toCharCode(char);\n      const nextChar = this.encodedName[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;\n        else pushByte(byte);\n      } else {\n        if (\n          (byte >= CharCodes.Zero && byte <= CharCodes.Nine) ||\n          (byte >= CharCodes.a && byte <= CharCodes.f) ||\n          (byte >= CharCodes.A && byte <= CharCodes.F)\n        ) {\n          hex += char;\n          if (\n            hex.length === 2 ||\n            !(\n              (nextChar >= '0' && nextChar <= '9') ||\n              (nextChar >= 'a' && nextChar <= 'f') ||\n              (nextChar >= 'A' && nextChar <= 'F')\n            )\n          ) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n\n    return new Uint8Array(bytes);\n  }\n\n  // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n  decodeText(): string {\n    const bytes = this.asBytes();\n    return String.fromCharCode(...Array.from(bytes));\n  }\n\n  asString(): string {\n    return this.encodedName;\n  }\n\n  /** @deprecated in favor of [[PDFName.asString]] */\n  value(): string {\n    return this.encodedName;\n  }\n\n  clone(): PDFName {\n    return this;\n  }\n\n  toString(): string {\n    return this.encodedName;\n  }\n\n  sizeInBytes(): number {\n    return this.encodedName.length;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  }\n}\n\nexport default PDFName;\n"]},"metadata":{},"sourceType":"module"}