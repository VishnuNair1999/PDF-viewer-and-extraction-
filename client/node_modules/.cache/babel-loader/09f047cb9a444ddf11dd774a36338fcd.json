{"ast":null,"code":"'use client';\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport { cancelRunningTask } from './shared/utils.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { eventProps, isClassName, isPdf, isRef } from './shared/propTypes.js';\n\nconst Outline = function Outline(props) {\n  const documentContext = useDocumentContext();\n  invariant(documentContext, 'Unable to find Document context. Did you wrap <Outline /> in <Document />?');\n  const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n\n  const {\n    className,\n    inputRef,\n    onItemClick,\n    onLoadError: onLoadErrorProps,\n    onLoadSuccess: onLoadSuccessProps,\n    pdf\n  } = mergedProps,\n        otherProps = __rest(mergedProps, [\"className\", \"inputRef\", \"onItemClick\", \"onLoadError\", \"onLoadSuccess\", \"pdf\"]);\n\n  invariant(pdf, 'Attempted to load an outline, but no document was specified.');\n  const [outlineState, outlineDispatch] = useResolver();\n  const {\n    value: outline,\n    error: outlineError\n  } = outlineState;\n  /**\n   * Called when an outline is read successfully\n   */\n\n  function onLoadSuccess() {\n    if (typeof outline === 'undefined' || outline === false) {\n      return;\n    }\n\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(outline);\n    }\n  }\n  /**\n   * Called when an outline failed to read successfully\n   */\n\n\n  function onLoadError() {\n    if (!outlineError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n\n    warning(false, outlineError.toString());\n\n    if (onLoadErrorProps) {\n      onLoadErrorProps(outlineError);\n    }\n  }\n\n  function resetOutline() {\n    outlineDispatch({\n      type: 'RESET'\n    });\n  }\n\n  useEffect(resetOutline, [outlineDispatch, pdf]);\n\n  function loadOutline() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n\n    const cancellable = makeCancellable(pdf.getOutline());\n    const runningTask = cancellable;\n    cancellable.promise.then(nextOutline => {\n      outlineDispatch({\n        type: 'RESOLVE',\n        value: nextOutline\n      });\n    }).catch(error => {\n      outlineDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => cancelRunningTask(runningTask);\n  }\n\n  useEffect(loadOutline, [outlineDispatch, pdf]);\n  useEffect(() => {\n    if (outline === undefined) {\n      return;\n    }\n\n    if (outline === false) {\n      onLoadError();\n      return;\n    }\n\n    onLoadSuccess();\n  }, // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [outline]);\n  const childContext = useMemo(() => ({\n    onItemClick\n  }), [onItemClick]);\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => outline), [otherProps, outline]);\n\n  if (!outline) {\n    return null;\n  }\n\n  function renderOutline() {\n    if (!outline) {\n      return null;\n    }\n\n    return React.createElement(\"ul\", null, outline.map((item, itemIndex) => React.createElement(OutlineItem, {\n      key: typeof item.dest === 'string' ? item.dest : itemIndex,\n      item: item\n    })));\n  }\n\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Outline', className),\n    ref: inputRef\n  }, eventProps), React.createElement(OutlineContext.Provider, {\n    value: childContext\n  }, renderOutline()));\n};\n\nOutline.propTypes = Object.assign(Object.assign({}, eventProps), {\n  className: isClassName,\n  inputRef: isRef,\n  onItemClick: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  pdf: isPdf\n});\nexport default Outline;","map":{"version":3,"sources":["C:/Users/vishn/Desktop/AuthInMern/client/node_modules/react-pdf/dist/esm/Outline.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","useEffect","useMemo","PropTypes","makeCancellable","makeEventProps","clsx","invariant","warning","OutlineContext","OutlineItem","cancelRunningTask","useDocumentContext","useResolver","eventProps","isClassName","isPdf","isRef","Outline","props","documentContext","mergedProps","assign","className","inputRef","onItemClick","onLoadError","onLoadErrorProps","onLoadSuccess","onLoadSuccessProps","pdf","otherProps","outlineState","outlineDispatch","value","outline","error","outlineError","toString","resetOutline","type","loadOutline","cancellable","getOutline","runningTask","promise","then","nextOutline","catch","undefined","childContext","renderOutline","createElement","map","item","itemIndex","key","dest","ref","Provider","propTypes","func"],"mappings":"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","sourcesContent":["'use client';\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport { cancelRunningTask } from './shared/utils.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { eventProps, isClassName, isPdf, isRef } from './shared/propTypes.js';\nconst Outline = function Outline(props) {\n    const documentContext = useDocumentContext();\n    invariant(documentContext, 'Unable to find Document context. Did you wrap <Outline /> in <Document />?');\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest(mergedProps, [\"className\", \"inputRef\", \"onItemClick\", \"onLoadError\", \"onLoadSuccess\", \"pdf\"]);\n    invariant(pdf, 'Attempted to load an outline, but no document was specified.');\n    const [outlineState, outlineDispatch] = useResolver();\n    const { value: outline, error: outlineError } = outlineState;\n    /**\n     * Called when an outline is read successfully\n     */\n    function onLoadSuccess() {\n        if (typeof outline === 'undefined' || outline === false) {\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(outline);\n        }\n    }\n    /**\n     * Called when an outline failed to read successfully\n     */\n    function onLoadError() {\n        if (!outlineError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning(false, outlineError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(outlineError);\n        }\n    }\n    function resetOutline() {\n        outlineDispatch({ type: 'RESET' });\n    }\n    useEffect(resetOutline, [outlineDispatch, pdf]);\n    function loadOutline() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        const cancellable = makeCancellable(pdf.getOutline());\n        const runningTask = cancellable;\n        cancellable.promise\n            .then((nextOutline) => {\n            outlineDispatch({ type: 'RESOLVE', value: nextOutline });\n        })\n            .catch((error) => {\n            outlineDispatch({ type: 'REJECT', error });\n        });\n        return () => cancelRunningTask(runningTask);\n    }\n    useEffect(loadOutline, [outlineDispatch, pdf]);\n    useEffect(() => {\n        if (outline === undefined) {\n            return;\n        }\n        if (outline === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [outline]);\n    const childContext = useMemo(() => ({\n        onItemClick,\n    }), [onItemClick]);\n    const eventProps = useMemo(() => makeEventProps(otherProps, () => outline), [otherProps, outline]);\n    if (!outline) {\n        return null;\n    }\n    function renderOutline() {\n        if (!outline) {\n            return null;\n        }\n        return (React.createElement(\"ul\", null, outline.map((item, itemIndex) => (React.createElement(OutlineItem, { key: typeof item.dest === 'string' ? item.dest : itemIndex, item: item })))));\n    }\n    return (React.createElement(\"div\", Object.assign({ className: clsx('react-pdf__Outline', className), ref: inputRef }, eventProps),\n        React.createElement(OutlineContext.Provider, { value: childContext }, renderOutline())));\n};\nOutline.propTypes = Object.assign(Object.assign({}, eventProps), { className: isClassName, inputRef: isRef, onItemClick: PropTypes.func, onLoadError: PropTypes.func, onLoadSuccess: PropTypes.func, pdf: isPdf });\nexport default Outline;\n"]},"metadata":{},"sourceType":"module"}