{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\n\nvar computeFontSize = function computeFontSize(lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n\n  var fontSize = MIN_FONT_SIZE;\n\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' '); // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n\n      var spaceInLineRemaining = bounds.width;\n\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    } // Return if we exceeded the allowed width\n\n\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed; // Return if we exceeded the allowed height\n\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nvar computeCombedFontSize = function computeCombedFontSize(line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nvar lastIndexOfWhitespace = function lastIndexOfWhitespace(line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n\n  return undefined;\n};\n\nvar splitOutLines = function splitOutLines(input, maxWidth, font, fontSize) {\n  var _a;\n\n  var lastWhitespaceIdx = input.length;\n\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  } // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n\n\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\n\nexport var layoutMultilineText = function layoutMultilineText(text, _a) {\n  var alignment = _a.alignment,\n      fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n          line = _b.line,\n          encoded = _b.encoded,\n          width = _b.width,\n          remainder = _b.remainder; // prettier-ignore\n\n\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }); // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function layoutCombedText(text, _a) {\n  var fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds,\n      cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n        char = _b[0],\n        charLength = _b[1];\n\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function layoutSinglelineText(text, _a) {\n  var alignment = _a.alignment,\n      fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  }); // prettier-ignore\n\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"sources":["C:\\Users\\vishn\\Desktop\\AuthInMern\\client\\node_modules\\pdf-lib\\src\\api\\text\\layout.ts"],"names":[],"mappings":"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","sourcesContent":["import PDFFont from 'src/api/PDFFont';\nimport { CombedTextLayoutError } from 'src/api/errors';\nimport { TextAlignment } from 'src/api/text/alignment';\n\nimport { PDFHexString } from 'src/core';\nimport {\n  cleanText,\n  lineSplit,\n  mergeLines,\n  charAtIndex,\n  charSplit,\n} from 'src/utils';\n\nexport interface TextPosition {\n  text: string;\n  encoded: PDFHexString;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface LayoutBounds {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nconst MIN_FONT_SIZE = 4;\nconst MAX_FONT_SIZE = 500;\n\nconst computeFontSize = (\n  lines: string[],\n  font: PDFFont,\n  bounds: LayoutBounds,\n  multiline: boolean = false,\n) => {\n  let fontSize = MIN_FONT_SIZE;\n\n  while (fontSize < MAX_FONT_SIZE) {\n    let linesUsed = 0;\n\n    for (\n      let lineIdx = 0, lineLen = lines.length;\n      lineIdx < lineLen;\n      lineIdx++\n    ) {\n      linesUsed += 1;\n\n      const line = lines[lineIdx];\n      const words = line.split(' ');\n\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      let spaceInLineRemaining = bounds.width;\n      for (let idx = 0, len = words.length; idx < len; idx++) {\n        const isLastWord = idx === len - 1;\n        const word = isLastWord ? words[idx] : words[idx] + ' ';\n        const widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n\n    const height = font.heightAtSize(fontSize);\n    const lineHeight = height + height * 0.2;\n    const totalHeight = lineHeight * linesUsed;\n\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nconst computeCombedFontSize = (\n  line: string,\n  font: PDFFont,\n  bounds: LayoutBounds,\n  cellCount: number,\n) => {\n  const cellWidth = bounds.width / cellCount;\n  const cellHeight = bounds.height;\n\n  let fontSize = MIN_FONT_SIZE;\n\n  const chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (let idx = 0, len = chars.length; idx < len; idx++) {\n      const c = chars[idx];\n      const tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n\n    const height = font.heightAtSize(fontSize, { descender: false });\n    if (height > cellHeight) return fontSize - 1;\n\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nexport interface LayoutTextOptions {\n  alignment: TextAlignment;\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n}\n\nexport interface MultilineTextLayout {\n  bounds: LayoutBounds;\n  lines: TextPosition[];\n  fontSize: number;\n  lineHeight: number;\n}\n\nconst lastIndexOfWhitespace = (line: string) => {\n  for (let idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\n\nconst splitOutLines = (\n  input: string,\n  maxWidth: number,\n  font: PDFFont,\n  fontSize: number,\n) => {\n  let lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    const line = input.substring(0, lastWhitespaceIdx);\n    const encoded = font.encodeText(line);\n    const width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      const remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return { line, encoded, width, remainder };\n    }\n    lastWhitespaceIdx = lastIndexOfWhitespace(line) ?? 0;\n  }\n\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined,\n  };\n};\n\nexport const layoutMultilineText = (\n  text: string,\n  { alignment, fontSize, font, bounds }: LayoutTextOptions,\n): MultilineTextLayout => {\n  const lines = lineSplit(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  const height = font.heightAtSize(fontSize);\n  const lineHeight = height + height * 0.2;\n\n  const textLines: TextPosition[] = [];\n\n  let minX = bounds.x;\n  let minY = bounds.y;\n  let maxX = bounds.x + bounds.width;\n  let maxY = bounds.y + bounds.height;\n\n  let y = bounds.y + bounds.height;\n  for (let idx = 0, len = lines.length; idx < len; idx++) {\n    let prevRemainder: string | undefined = lines[idx];\n    while (prevRemainder !== undefined) {\n      const { line, encoded, width, remainder } = splitOutLines(\n        prevRemainder,\n        bounds.width,\n        font,\n        fontSize,\n      );\n\n      // prettier-ignore\n      const x = (\n          alignment === TextAlignment.Left   ? bounds.x\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n        : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\n        : bounds.x\n      );\n\n      y -= lineHeight;\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n\n      textLines.push({ text: line, encoded, width, height, x, y });\n\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder?.trim();\n    }\n  }\n\n  return {\n    fontSize,\n    lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n};\n\nexport interface LayoutCombedTextOptions {\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n  cellCount: number;\n}\n\nexport interface CombedTextLayout {\n  bounds: LayoutBounds;\n  cells: TextPosition[];\n  fontSize: number;\n}\n\nexport const layoutCombedText = (\n  text: string,\n  { fontSize, font, bounds, cellCount }: LayoutCombedTextOptions,\n): CombedTextLayout => {\n  const line = mergeLines(cleanText(text));\n\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n\n  const cellWidth = bounds.width / cellCount;\n\n  const height = font.heightAtSize(fontSize, { descender: false });\n  const y = bounds.y + (bounds.height / 2 - height / 2);\n\n  const cells: TextPosition[] = [];\n\n  let minX = bounds.x;\n  let minY = bounds.y;\n  let maxX = bounds.x + bounds.width;\n  let maxY = bounds.y + bounds.height;\n\n  let cellOffset = 0;\n  let charOffset = 0;\n  while (cellOffset < cellCount) {\n    const [char, charLength] = charAtIndex(line, charOffset);\n\n    const encoded = font.encodeText(char);\n    const width = font.widthOfTextAtSize(char, fontSize);\n\n    const cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    const x = cellCenter - width / 2;\n\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n\n    cells.push({ text: line, encoded, width, height, x, y });\n\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n\n  return {\n    fontSize,\n    cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n};\n\nexport interface LayoutSinglelineTextOptions {\n  alignment: TextAlignment;\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n}\n\nexport interface SinglelineTextLayout {\n  bounds: LayoutBounds;\n  line: TextPosition;\n  fontSize: number;\n}\n\nexport const layoutSinglelineText = (\n  text: string,\n  { alignment, fontSize, font, bounds }: LayoutSinglelineTextOptions,\n): SinglelineTextLayout => {\n  const line = mergeLines(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n\n  const encoded = font.encodeText(line);\n  const width = font.widthOfTextAtSize(line, fontSize);\n  const height = font.heightAtSize(fontSize, { descender: false });\n\n  // prettier-ignore\n  const x = (\n      alignment === TextAlignment.Left   ? bounds.x\n    : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n    : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\n    : bounds.x\n  );\n\n  const y = bounds.y + (bounds.height / 2 - height / 2);\n\n  return {\n    fontSize,\n    line: { text: line, encoded, width, height, x, y },\n    bounds: { x, y, width, height },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}