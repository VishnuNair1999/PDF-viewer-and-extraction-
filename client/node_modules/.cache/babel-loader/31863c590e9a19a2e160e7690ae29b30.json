{"ast":null,"code":"'use client';\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport pdfjs from '../pdfjs.js';\nimport StructTree from '../StructTree.js';\nimport usePageContext from '../shared/hooks/usePageContext.js';\nimport { cancelRunningTask, getDevicePixelRatio, isCancelException, makePageCallback } from '../shared/utils.js';\nconst ANNOTATION_MODE = pdfjs.AnnotationMode;\nexport default function PageCanvas(props) {\n  const pageContext = usePageContext();\n  invariant(pageContext, 'Unable to find Page context.');\n  const mergedProps = Object.assign(Object.assign({}, pageContext), props);\n  const {\n    _className,\n    canvasBackground,\n    devicePixelRatio = getDevicePixelRatio(),\n    onRenderError: onRenderErrorProps,\n    onRenderSuccess: onRenderSuccessProps,\n    page,\n    renderForms,\n    renderTextLayer,\n    rotate,\n    scale\n  } = mergedProps;\n  const {\n    canvasRef\n  } = props;\n  invariant(page, 'Attempted to render page canvas, but no page was specified.');\n  const canvasElement = useRef(null);\n  /**\n   * Called when a page is rendered successfully.\n   */\n\n  function onRenderSuccess() {\n    if (!page) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n\n    if (onRenderSuccessProps) {\n      onRenderSuccessProps(makePageCallback(page, scale));\n    }\n  }\n  /**\n   * Called when a page fails to render.\n   */\n\n\n  function onRenderError(error) {\n    if (isCancelException(error)) {\n      return;\n    }\n\n    warning(false, error.toString());\n\n    if (onRenderErrorProps) {\n      onRenderErrorProps(error);\n    }\n  }\n\n  const renderViewport = useMemo(() => page.getViewport({\n    scale: scale * devicePixelRatio,\n    rotation: rotate\n  }), [devicePixelRatio, page, rotate, scale]);\n  const viewport = useMemo(() => page.getViewport({\n    scale,\n    rotation: rotate\n  }), [page, rotate, scale]);\n\n  function drawPageOnCanvas() {\n    if (!page) {\n      return;\n    } // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n\n\n    page.cleanup();\n    const {\n      current: canvas\n    } = canvasElement;\n\n    if (!canvas) {\n      return;\n    }\n\n    canvas.width = renderViewport.width;\n    canvas.height = renderViewport.height;\n    canvas.style.width = `${Math.floor(viewport.width)}px`;\n    canvas.style.height = `${Math.floor(viewport.height)}px`;\n    canvas.style.visibility = 'hidden';\n    const renderContext = {\n      annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n      canvasContext: canvas.getContext('2d', {\n        alpha: false\n      }),\n      viewport: renderViewport\n    };\n\n    if (canvasBackground) {\n      renderContext.background = canvasBackground;\n    }\n\n    const cancellable = page.render(renderContext);\n    const runningTask = cancellable;\n    cancellable.promise.then(() => {\n      canvas.style.visibility = '';\n      onRenderSuccess();\n    }).catch(onRenderError);\n    return () => cancelRunningTask(runningTask);\n  }\n\n  useEffect(drawPageOnCanvas, // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [canvasBackground, canvasElement, devicePixelRatio, page, renderForms, renderViewport, viewport]);\n  const cleanup = useCallback(() => {\n    const {\n      current: canvas\n    } = canvasElement;\n    /**\n     * Zeroing the width and height cause most browsers to release graphics\n     * resources immediately, which can greatly reduce memory consumption.\n     */\n\n    if (canvas) {\n      canvas.width = 0;\n      canvas.height = 0;\n    }\n  }, [canvasElement]);\n  useEffect(() => cleanup, [cleanup]);\n  return React.createElement(\"canvas\", {\n    className: `${_className}__canvas`,\n    dir: \"ltr\",\n    ref: mergeRefs(canvasRef, canvasElement),\n    style: {\n      display: 'block',\n      userSelect: 'none'\n    }\n  }, renderTextLayer ? React.createElement(StructTree, null) : null);\n}","map":{"version":3,"sources":["C:/Users/vishn/Desktop/AuthInMern/client/node_modules/react-pdf/dist/esm/Page/PageCanvas.js"],"names":["React","useCallback","useEffect","useMemo","useRef","mergeRefs","invariant","warning","pdfjs","StructTree","usePageContext","cancelRunningTask","getDevicePixelRatio","isCancelException","makePageCallback","ANNOTATION_MODE","AnnotationMode","PageCanvas","props","pageContext","mergedProps","Object","assign","_className","canvasBackground","devicePixelRatio","onRenderError","onRenderErrorProps","onRenderSuccess","onRenderSuccessProps","page","renderForms","renderTextLayer","rotate","scale","canvasRef","canvasElement","error","toString","renderViewport","getViewport","rotation","viewport","drawPageOnCanvas","cleanup","current","canvas","width","height","style","Math","floor","visibility","renderContext","annotationMode","ENABLE_FORMS","ENABLE","canvasContext","getContext","alpha","background","cancellable","render","runningTask","promise","then","catch","createElement","className","dir","ref","display","userSelect"],"mappings":"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","sourcesContent":["'use client';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport pdfjs from '../pdfjs.js';\nimport StructTree from '../StructTree.js';\nimport usePageContext from '../shared/hooks/usePageContext.js';\nimport { cancelRunningTask, getDevicePixelRatio, isCancelException, makePageCallback, } from '../shared/utils.js';\nconst ANNOTATION_MODE = pdfjs.AnnotationMode;\nexport default function PageCanvas(props) {\n    const pageContext = usePageContext();\n    invariant(pageContext, 'Unable to find Page context.');\n    const mergedProps = Object.assign(Object.assign({}, pageContext), props);\n    const { _className, canvasBackground, devicePixelRatio = getDevicePixelRatio(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale, } = mergedProps;\n    const { canvasRef } = props;\n    invariant(page, 'Attempted to render page canvas, but no page was specified.');\n    const canvasElement = useRef(null);\n    /**\n     * Called when a page is rendered successfully.\n     */\n    function onRenderSuccess() {\n        if (!page) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onRenderSuccessProps) {\n            onRenderSuccessProps(makePageCallback(page, scale));\n        }\n    }\n    /**\n     * Called when a page fails to render.\n     */\n    function onRenderError(error) {\n        if (isCancelException(error)) {\n            return;\n        }\n        warning(false, error.toString());\n        if (onRenderErrorProps) {\n            onRenderErrorProps(error);\n        }\n    }\n    const renderViewport = useMemo(() => page.getViewport({ scale: scale * devicePixelRatio, rotation: rotate }), [devicePixelRatio, page, rotate, scale]);\n    const viewport = useMemo(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);\n    function drawPageOnCanvas() {\n        if (!page) {\n            return;\n        }\n        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n        page.cleanup();\n        const { current: canvas } = canvasElement;\n        if (!canvas) {\n            return;\n        }\n        canvas.width = renderViewport.width;\n        canvas.height = renderViewport.height;\n        canvas.style.width = `${Math.floor(viewport.width)}px`;\n        canvas.style.height = `${Math.floor(viewport.height)}px`;\n        canvas.style.visibility = 'hidden';\n        const renderContext = {\n            annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n            canvasContext: canvas.getContext('2d', { alpha: false }),\n            viewport: renderViewport,\n        };\n        if (canvasBackground) {\n            renderContext.background = canvasBackground;\n        }\n        const cancellable = page.render(renderContext);\n        const runningTask = cancellable;\n        cancellable.promise\n            .then(() => {\n            canvas.style.visibility = '';\n            onRenderSuccess();\n        })\n            .catch(onRenderError);\n        return () => cancelRunningTask(runningTask);\n    }\n    useEffect(drawPageOnCanvas, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        canvasBackground,\n        canvasElement,\n        devicePixelRatio,\n        page,\n        renderForms,\n        renderViewport,\n        viewport,\n    ]);\n    const cleanup = useCallback(() => {\n        const { current: canvas } = canvasElement;\n        /**\n         * Zeroing the width and height cause most browsers to release graphics\n         * resources immediately, which can greatly reduce memory consumption.\n         */\n        if (canvas) {\n            canvas.width = 0;\n            canvas.height = 0;\n        }\n    }, [canvasElement]);\n    useEffect(() => cleanup, [cleanup]);\n    return (React.createElement(\"canvas\", { className: `${_className}__canvas`, dir: \"ltr\", ref: mergeRefs(canvasRef, canvasElement), style: {\n            display: 'block',\n            userSelect: 'none',\n        } }, renderTextLayer ? React.createElement(StructTree, null) : null));\n}\n"]},"metadata":{},"sourceType":"module"}