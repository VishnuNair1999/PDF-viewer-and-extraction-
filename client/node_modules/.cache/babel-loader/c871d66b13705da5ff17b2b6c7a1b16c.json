{"ast":null,"code":"'use client';\n\nimport React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef } from 'react';\nimport makeCancellable from 'make-cancellable-promise';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport pdfjs from '../pdfjs.js';\nimport usePageContext from '../shared/hooks/usePageContext.js';\nimport useResolver from '../shared/hooks/useResolver.js';\nimport { cancelRunningTask } from '../shared/utils.js';\n\nfunction isTextItem(item) {\n  return 'str' in item;\n}\n\nexport default function TextLayer() {\n  const pageContext = usePageContext();\n  invariant(pageContext, 'Unable to find Page context.');\n  const {\n    customTextRenderer,\n    onGetTextError,\n    onGetTextSuccess,\n    onRenderTextLayerError,\n    onRenderTextLayerSuccess,\n    page,\n    pageIndex,\n    pageNumber,\n    rotate,\n    scale\n  } = pageContext;\n  invariant(page, 'Attempted to load page text content, but no page was specified.');\n  const [textContentState, textContentDispatch] = useResolver();\n  const {\n    value: textContent,\n    error: textContentError\n  } = textContentState;\n  const layerElement = useRef(null);\n  const endElement = useRef();\n  warning(parseInt(window.getComputedStyle(document.body).getPropertyValue('--react-pdf-text-layer'), 10) === 1, 'TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer');\n  /**\n   * Called when a page text content is read successfully\n   */\n\n  function onLoadSuccess() {\n    if (!textContent) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n\n    if (onGetTextSuccess) {\n      onGetTextSuccess(textContent);\n    }\n  }\n  /**\n   * Called when a page text content failed to read successfully\n   */\n\n\n  function onLoadError() {\n    if (!textContentError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n\n    warning(false, textContentError.toString());\n\n    if (onGetTextError) {\n      onGetTextError(textContentError);\n    }\n  }\n\n  function resetTextContent() {\n    textContentDispatch({\n      type: 'RESET'\n    });\n  }\n\n  useEffect(resetTextContent, [page, textContentDispatch]);\n\n  function loadTextContent() {\n    if (!page) {\n      return;\n    }\n\n    const cancellable = makeCancellable(page.getTextContent());\n    const runningTask = cancellable;\n    cancellable.promise.then(nextTextContent => {\n      textContentDispatch({\n        type: 'RESOLVE',\n        value: nextTextContent\n      });\n    }).catch(error => {\n      textContentDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => cancelRunningTask(runningTask);\n  }\n\n  useEffect(loadTextContent, [page, textContentDispatch]);\n  useEffect(() => {\n    if (textContent === undefined) {\n      return;\n    }\n\n    if (textContent === false) {\n      onLoadError();\n      return;\n    }\n\n    onLoadSuccess();\n  }, // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [textContent]);\n  /**\n   * Called when a text layer is rendered successfully\n   */\n\n  const onRenderSuccess = useCallback(() => {\n    if (onRenderTextLayerSuccess) {\n      onRenderTextLayerSuccess();\n    }\n  }, [onRenderTextLayerSuccess]);\n  /**\n   * Called when a text layer failed to render successfully\n   */\n\n  const onRenderError = useCallback(error => {\n    warning(false, error.toString());\n\n    if (onRenderTextLayerError) {\n      onRenderTextLayerError(error);\n    }\n  }, [onRenderTextLayerError]);\n\n  function onMouseDown() {\n    const end = endElement.current;\n\n    if (!end) {\n      return;\n    }\n\n    end.classList.add('active');\n  }\n\n  function onMouseUp() {\n    const end = endElement.current;\n\n    if (!end) {\n      return;\n    }\n\n    end.classList.remove('active');\n  }\n\n  const viewport = useMemo(() => page.getViewport({\n    scale,\n    rotation: rotate\n  }), [page, rotate, scale]);\n\n  function renderTextLayer() {\n    if (!page || !textContent) {\n      return;\n    }\n\n    const {\n      current: layer\n    } = layerElement;\n\n    if (!layer) {\n      return;\n    }\n\n    layer.innerHTML = '';\n    const textContentSource = page.streamTextContent({\n      includeMarkedContent: true\n    });\n    const parameters = {\n      container: layer,\n      textContentSource,\n      viewport\n    };\n    const cancellable = pdfjs.renderTextLayer(parameters);\n    const runningTask = cancellable;\n    cancellable.promise.then(() => {\n      const end = document.createElement('div');\n      end.className = 'endOfContent';\n      layer.append(end);\n      endElement.current = end;\n      const layerChildren = layer.querySelectorAll('[role=\"presentation\"]');\n\n      if (customTextRenderer) {\n        let index = 0;\n        textContent.items.forEach((item, itemIndex) => {\n          if (!isTextItem(item)) {\n            return;\n          }\n\n          const child = layerChildren[index];\n\n          if (!child) {\n            return;\n          }\n\n          const content = customTextRenderer(Object.assign({\n            pageIndex,\n            pageNumber,\n            itemIndex\n          }, item));\n          child.innerHTML = content;\n          index += item.str && item.hasEOL ? 2 : 1;\n        });\n      } // Intentional immediate callback\n\n\n      onRenderSuccess();\n    }).catch(onRenderError);\n    return () => cancelRunningTask(runningTask);\n  }\n\n  useLayoutEffect(renderTextLayer, [customTextRenderer, onRenderError, onRenderSuccess, page, pageIndex, pageNumber, textContent, viewport]);\n  return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    React.createElement(\"div\", {\n      className: clsx('react-pdf__Page__textContent', 'textLayer'),\n      onMouseUp: onMouseUp,\n      onMouseDown: onMouseDown,\n      ref: layerElement\n    })\n  );\n}","map":{"version":3,"sources":["C:/Users/vishn/Desktop/AuthInMern/client/node_modules/react-pdf/dist/esm/Page/TextLayer.js"],"names":["React","useCallback","useEffect","useLayoutEffect","useMemo","useRef","makeCancellable","clsx","invariant","warning","pdfjs","usePageContext","useResolver","cancelRunningTask","isTextItem","item","TextLayer","pageContext","customTextRenderer","onGetTextError","onGetTextSuccess","onRenderTextLayerError","onRenderTextLayerSuccess","page","pageIndex","pageNumber","rotate","scale","textContentState","textContentDispatch","value","textContent","error","textContentError","layerElement","endElement","parseInt","window","getComputedStyle","document","body","getPropertyValue","onLoadSuccess","onLoadError","toString","resetTextContent","type","loadTextContent","cancellable","getTextContent","runningTask","promise","then","nextTextContent","catch","undefined","onRenderSuccess","onRenderError","onMouseDown","end","current","classList","add","onMouseUp","remove","viewport","getViewport","rotation","renderTextLayer","layer","innerHTML","textContentSource","streamTextContent","includeMarkedContent","parameters","container","createElement","className","append","layerChildren","querySelectorAll","index","items","forEach","itemIndex","child","content","Object","assign","str","hasEOL","ref"],"mappings":"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","sourcesContent":["'use client';\nimport React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef } from 'react';\nimport makeCancellable from 'make-cancellable-promise';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport pdfjs from '../pdfjs.js';\nimport usePageContext from '../shared/hooks/usePageContext.js';\nimport useResolver from '../shared/hooks/useResolver.js';\nimport { cancelRunningTask } from '../shared/utils.js';\nfunction isTextItem(item) {\n    return 'str' in item;\n}\nexport default function TextLayer() {\n    const pageContext = usePageContext();\n    invariant(pageContext, 'Unable to find Page context.');\n    const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale, } = pageContext;\n    invariant(page, 'Attempted to load page text content, but no page was specified.');\n    const [textContentState, textContentDispatch] = useResolver();\n    const { value: textContent, error: textContentError } = textContentState;\n    const layerElement = useRef(null);\n    const endElement = useRef();\n    warning(parseInt(window.getComputedStyle(document.body).getPropertyValue('--react-pdf-text-layer'), 10) === 1, 'TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer');\n    /**\n     * Called when a page text content is read successfully\n     */\n    function onLoadSuccess() {\n        if (!textContent) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetTextSuccess) {\n            onGetTextSuccess(textContent);\n        }\n    }\n    /**\n     * Called when a page text content failed to read successfully\n     */\n    function onLoadError() {\n        if (!textContentError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning(false, textContentError.toString());\n        if (onGetTextError) {\n            onGetTextError(textContentError);\n        }\n    }\n    function resetTextContent() {\n        textContentDispatch({ type: 'RESET' });\n    }\n    useEffect(resetTextContent, [page, textContentDispatch]);\n    function loadTextContent() {\n        if (!page) {\n            return;\n        }\n        const cancellable = makeCancellable(page.getTextContent());\n        const runningTask = cancellable;\n        cancellable.promise\n            .then((nextTextContent) => {\n            textContentDispatch({ type: 'RESOLVE', value: nextTextContent });\n        })\n            .catch((error) => {\n            textContentDispatch({ type: 'REJECT', error });\n        });\n        return () => cancelRunningTask(runningTask);\n    }\n    useEffect(loadTextContent, [page, textContentDispatch]);\n    useEffect(() => {\n        if (textContent === undefined) {\n            return;\n        }\n        if (textContent === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [textContent]);\n    /**\n     * Called when a text layer is rendered successfully\n     */\n    const onRenderSuccess = useCallback(() => {\n        if (onRenderTextLayerSuccess) {\n            onRenderTextLayerSuccess();\n        }\n    }, [onRenderTextLayerSuccess]);\n    /**\n     * Called when a text layer failed to render successfully\n     */\n    const onRenderError = useCallback((error) => {\n        warning(false, error.toString());\n        if (onRenderTextLayerError) {\n            onRenderTextLayerError(error);\n        }\n    }, [onRenderTextLayerError]);\n    function onMouseDown() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.add('active');\n    }\n    function onMouseUp() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.remove('active');\n    }\n    const viewport = useMemo(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);\n    function renderTextLayer() {\n        if (!page || !textContent) {\n            return;\n        }\n        const { current: layer } = layerElement;\n        if (!layer) {\n            return;\n        }\n        layer.innerHTML = '';\n        const textContentSource = page.streamTextContent({ includeMarkedContent: true });\n        const parameters = {\n            container: layer,\n            textContentSource,\n            viewport,\n        };\n        const cancellable = pdfjs.renderTextLayer(parameters);\n        const runningTask = cancellable;\n        cancellable.promise\n            .then(() => {\n            const end = document.createElement('div');\n            end.className = 'endOfContent';\n            layer.append(end);\n            endElement.current = end;\n            const layerChildren = layer.querySelectorAll('[role=\"presentation\"]');\n            if (customTextRenderer) {\n                let index = 0;\n                textContent.items.forEach((item, itemIndex) => {\n                    if (!isTextItem(item)) {\n                        return;\n                    }\n                    const child = layerChildren[index];\n                    if (!child) {\n                        return;\n                    }\n                    const content = customTextRenderer(Object.assign({ pageIndex,\n                        pageNumber,\n                        itemIndex }, item));\n                    child.innerHTML = content;\n                    index += item.str && item.hasEOL ? 2 : 1;\n                });\n            }\n            // Intentional immediate callback\n            onRenderSuccess();\n        })\n            .catch(onRenderError);\n        return () => cancelRunningTask(runningTask);\n    }\n    useLayoutEffect(renderTextLayer, [\n        customTextRenderer,\n        onRenderError,\n        onRenderSuccess,\n        page,\n        pageIndex,\n        pageNumber,\n        textContent,\n        viewport,\n    ]);\n    return (\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    React.createElement(\"div\", { className: clsx('react-pdf__Page__textContent', 'textLayer'), onMouseUp: onMouseUp, onMouseDown: onMouseDown, ref: layerElement }));\n}\n"]},"metadata":{},"sourceType":"module"}