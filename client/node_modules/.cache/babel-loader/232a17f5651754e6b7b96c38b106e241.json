{"ast":null,"code":"import PDFNumber from \"../objects/PDFNumber\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport PDFAcroNonTerminal from \"./PDFAcroNonTerminal\";\nimport PDFAcroSignature from \"./PDFAcroSignature\";\nimport PDFAcroText from \"./PDFAcroText\";\nimport PDFAcroPushButton from \"./PDFAcroPushButton\";\nimport PDFAcroRadioButton from \"./PDFAcroRadioButton\";\nimport PDFAcroCheckBox from \"./PDFAcroCheckBox\";\nimport PDFAcroComboBox from \"./PDFAcroComboBox\";\nimport PDFAcroListBox from \"./PDFAcroListBox\";\nimport { AcroButtonFlags, AcroChoiceFlags } from \"./flags\";\nexport var createPDFAcroFields = function createPDFAcroFields(kidDicts) {\n  if (!kidDicts) return [];\n  var kids = [];\n\n  for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    var ref = kidDicts.get(idx);\n    var dict = kidDicts.lookup(idx); // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n\n    if (ref instanceof PDFRef && dict instanceof PDFDict) {\n      kids.push([createPDFAcroField(dict, ref), ref]);\n    }\n  }\n\n  return kids;\n};\nexport var createPDFAcroField = function createPDFAcroField(dict, ref) {\n  var isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n}; // TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\n\nvar isNonTerminalAcroField = function isNonTerminalAcroField(dict) {\n  var kids = dict.lookup(PDFName.of('Kids'));\n\n  if (kids instanceof PDFArray) {\n    for (var idx = 0, len = kids.size(); idx < len; idx++) {\n      var kid = kids.lookup(idx);\n      var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n\n  return false;\n};\n\nvar createPDFAcroTerminal = function createPDFAcroTerminal(dict, ref) {\n  var ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n  var type = dict.context.lookup(ftNameOrRef, PDFName);\n  if (type === PDFName.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName.of('Tx')) return PDFAcroText.fromDict(dict, ref);\n  if (type === PDFName.of('Sig')) return PDFAcroSignature.fromDict(dict, ref); // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n\n  return PDFAcroTerminal.fromDict(dict, ref);\n};\n\nvar createPDFAcroButton = function createPDFAcroButton(dict, ref) {\n  var _a;\n\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n\n  if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton.fromDict(dict, ref);\n  } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox.fromDict(dict, ref);\n  }\n};\n\nvar createPDFAcroChoice = function createPDFAcroChoice(dict, ref) {\n  var _a;\n\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n\n  if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox.fromDict(dict, ref);\n  }\n};\n\nvar flagIsSet = function flagIsSet(flags, flag) {\n  return (flags & flag) !== 0;\n};\n\nvar getInheritableAttribute = function getInheritableAttribute(startNode, name) {\n  var attribute;\n  ascend(startNode, function (node) {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\n\nvar ascend = function ascend(startNode, visitor) {\n  visitor(startNode);\n  var Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n  if (Parent) ascend(Parent, visitor);\n};","map":{"version":3,"sources":["C:\\Users\\vishn\\Desktop\\AuthInMern\\client\\node_modules\\pdf-lib\\src\\core\\acroform\\utils.ts"],"names":[],"mappings":"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","sourcesContent":["import PDFObject from 'src/core/objects/PDFObject';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFDict from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFArray from 'src/core/objects/PDFArray';\nimport PDFRef from 'src/core/objects/PDFRef';\n\nimport PDFAcroField from 'src/core/acroform/PDFAcroField';\nimport PDFAcroTerminal from 'src/core/acroform/PDFAcroTerminal';\nimport PDFAcroNonTerminal from 'src/core/acroform/PDFAcroNonTerminal';\nimport PDFAcroButton from 'src/core/acroform/PDFAcroButton';\nimport PDFAcroSignature from 'src/core/acroform/PDFAcroSignature';\nimport PDFAcroChoice from 'src/core/acroform/PDFAcroChoice';\nimport PDFAcroText from 'src/core/acroform/PDFAcroText';\nimport PDFAcroPushButton from 'src/core/acroform/PDFAcroPushButton';\nimport PDFAcroRadioButton from 'src/core/acroform/PDFAcroRadioButton';\nimport PDFAcroCheckBox from 'src/core/acroform/PDFAcroCheckBox';\nimport PDFAcroComboBox from 'src/core/acroform/PDFAcroComboBox';\nimport PDFAcroListBox from 'src/core/acroform/PDFAcroListBox';\nimport { AcroButtonFlags, AcroChoiceFlags } from 'src/core/acroform/flags';\n\nexport const createPDFAcroFields = (\n  kidDicts?: PDFArray,\n): [PDFAcroField, PDFRef][] => {\n  if (!kidDicts) return [];\n\n  const kids: [PDFAcroField, PDFRef][] = [];\n  for (let idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    const ref = kidDicts.get(idx);\n    const dict = kidDicts.lookup(idx);\n    // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n    if (ref instanceof PDFRef && dict instanceof PDFDict) {\n      kids.push([createPDFAcroField(dict, ref), ref]);\n    }\n  }\n\n  return kids;\n};\n\nexport const createPDFAcroField = (\n  dict: PDFDict,\n  ref: PDFRef,\n): PDFAcroField => {\n  const isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n};\n\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nconst isNonTerminalAcroField = (dict: PDFDict): boolean => {\n  const kids = dict.lookup(PDFName.of('Kids'));\n\n  if (kids instanceof PDFArray) {\n    for (let idx = 0, len = kids.size(); idx < len; idx++) {\n      const kid = kids.lookup(idx);\n      const kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n\n  return false;\n};\n\nconst createPDFAcroTerminal = (dict: PDFDict, ref: PDFRef): PDFAcroTerminal => {\n  const ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n  const type = dict.context.lookup(ftNameOrRef, PDFName);\n\n  if (type === PDFName.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName.of('Tx')) return PDFAcroText.fromDict(dict, ref);\n  if (type === PDFName.of('Sig')) return PDFAcroSignature.fromDict(dict, ref);\n\n  // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n  return PDFAcroTerminal.fromDict(dict, ref);\n};\n\nconst createPDFAcroButton = (dict: PDFDict, ref: PDFRef): PDFAcroButton => {\n  const ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  const ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  const flags = ffNumber?.asNumber() ?? 0;\n\n  if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton.fromDict(dict, ref);\n  } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox.fromDict(dict, ref);\n  }\n};\n\nconst createPDFAcroChoice = (dict: PDFDict, ref: PDFRef): PDFAcroChoice => {\n  const ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  const ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  const flags = ffNumber?.asNumber() ?? 0;\n\n  if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox.fromDict(dict, ref);\n  }\n};\n\nconst flagIsSet = (flags: number, flag: number): boolean =>\n  (flags & flag) !== 0;\n\nconst getInheritableAttribute = (startNode: PDFDict, name: PDFName) => {\n  let attribute: PDFObject | undefined;\n  ascend(startNode, (node) => {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\n\nconst ascend = (startNode: PDFDict, visitor: (node: PDFDict) => any) => {\n  visitor(startNode);\n  const Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n  if (Parent) ascend(Parent, visitor);\n};\n"]},"metadata":{},"sourceType":"module"}